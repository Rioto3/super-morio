# Super Morio - プロジェクト管理原則

## 1. プロジェクトスタイル

### 1.1 開発アプローチ
- 柔軟な個人開発モデル
- MVPファーストの戦略
- 学習と実験を重視
- AIによる主要な開発作業

### 1.2 開発サイクル
- 厳格なスプリントではなく、柔軟な進化
- 必要に応じて大胆な実装とリファクタリング
- ユーザーフィードバックと発見したバグに基づく迅速な改善
- 形式的なミーティングなし

## 2. コミュニケーション方法

### 2.1 設計・アーキテクチャの情報共有

#### 2.1.1 基本コミュニケーションルール
- 人間（開発者）：自由形式の言語ベースで情報を提供
- AI：`tree`コマンド形式で抽象的な構造を視覚化

#### 2.1.2 `tree`フォーマットのガイドライン
```
プロジェクト名/
│
├── カテゴリ: カテゴリの簡潔な説明
│   ├── コンポーネント: コンポーネントの機能説明
│   └── コンポーネント: コンポーネントの機能説明
│
└── 他のカテゴリ: 他のカテゴリの説明
```

##### 重要なルール
- 拡張子は省略
- コンポーネント名の後にコロン（:）で簡潔な説明を追加
- 階層的な構造を明確に表現
- 抽象的な概念や設計を共有する際に使用

### 2.2 コミュニケーションの基本原則
- 簡潔性
- 明確さ
- 柔軟性
- 相互理解の重視

## 3. テクニカルアプローチ

### 3.1 デプロイメント
- Vercelを使用した継続的デプロイメント
- 迅速かつ低オーバーヘッドな公開プロセス

### 3.2 技術選択の哲学
- 学習と実験を最優先
- 最小限の技術的負債
- 柔軟性と拡張性の確保

## 4. 開発戦略

### 4.1 MVP (Minimum Viable Product)
- 最小限の機能で早期リリース
- 継続的な機能追加と改善
- ユーザーからの直接的なフィードバック重視

### 4.2 イテレーション
- 大胆な実装
- 必要に応じて大規模なリファクタリング
- 技術的・ゲーム性の両面で継続的な改善

## 5. コミュニケーションと貢献

### 5.1 開発コミュニケーション
- 形式的なドキュメンテーションの最小化
- 必要最小限の情報共有
- 開発者（AI）と管理者の密接な連携

### 5.2 ユーザーインタラクション
- GitHubのIssueを通じた簡易的なフィードバック収集
- 直接的で迅速な対応
- 複雑な貢献ガイドラインは不要

## 6. 技術的柔軟性

### 6.1 技術スタックの進化
- 新しい技術への継続的な探求
- 学習と改善を最優先
- 必要に応じて技術スタックの大胆な変更

### 6.2 AIを中心とした開発
- AI（この会話のAIアシスタント）が主要な開発担当
- 人間は戦略、方向性、最終的な意思決定に集中

## 7. リスクと持続可能性

### 7.1 開発リスク管理
- 小さく、迅速な実験
- 失敗を学習の機会と捉える
- 技術的負債の継続的な評価と管理

### 7.2 長期ビジョン
- プロジェクトの有機的な成長
- 楽しみと学習を中心に据える
- 柔軟な目標設定

## 8. プロジェクトツールエコシステム

### 8.1 主要開発ツール

#### 8.1.1 AI開発パートナー
- **Claude**: 
  - メインのプロジェクトAI
  - 高次元的思考と戦略立案
  - 包括的な開発支援

- **Cursor**: 
  - AI統合コードエディタ
  - コードの修正and生成
  - 補助的な開発ツール

#### 8.1.2 フレームワークとライブラリ
- **Next.js (v15.1.3)**: 
  - メインのウェブフレームワーク
  - React Server Components使用
  - 注意点: `'use client'`ディレクティブに注意

- **メインライブラリ**:
  ```
  "dependencies": {
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.469.0",
    "next": "15.1.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^2.6.0"
  }
  ```

#### 8.1.3 開発支援ツール
- **GitHub**: 
  - ソース管理
  - コラボレーション
  - イシュートラッキング

- **Vercel**: 
  - ホスティングプラットフォーム
  - 継続的デプロイメント

- **Sourcetree**: 
  - Git可視化ツール
  - リポジトリ管理の補助

### 8.2 ツール選択の基本方針
- 柔軟性の確保
- 学習と実験の容易さ
- 最小限の設定オーバーヘッド
- AIとの効果的な協働

## 9. 技術的負債の管理アプローチ

### 9.1 基本方針
- Claude and Cursorによる初期実装
- 開発者の理解が追いつかない箇所を随時確認
- リファクタリングは対話的プロセス
  - 開発者がリファクタリングの必要性を提起
  - AIが具体的な改善提案
  - 共同で理解を深めながら実装

### 9.2 リファクタリングの特徴
- 必要に応じて柔軟に実施
- 共同理解を重視
- 技術的負債は実際の改善プロセスで明確化

### 9.3 情報の最新性と階層

#### 情報更新の優先順位
1. README.md: 
   - ユーザーガイド
   - プロジェクト概要
   - 設計概要

2. 2.project_current_status[id].md:
   - 最新の詳細な状況
   - 最新のtree状設計
   - 現在の進捗

3. 1.project_management_principles.md:
   - 長期的な原則
   - 変更の少ない基本方針

### 9.4 project_current_status[id].mdの構造例
```
super-morio/
│
├── current_design: 最新の設計概要
│   ├── game_engine: ゲームエンジンの現在の構造
│   ├── components: 主要コンポーネントの状態
│   └── integration: システム統合の現状
│
├── progress: 開発進捗
│   ├── completed_features: 実装済み機能
│   ├── in_progress: 開発中の機能
│   └── next_milestones: 次の目標
│
└── challenges: 現在の課題
    ├── technical_debt: 認識された技術的課題
    └── improvement_areas: 改善が必要な領域
```

## 10. ドキュメント管理と更新プロセス

### 10.1 動的更新の基本原則
- 継続的な情報の最適化
- 矛盾と重複の自動検出
- ユーザーとの対話的な更新プロセス

### 10.2 更新検出メカニズム
- AIの責任：
  1. 2.project_current_status[id].md の変更を継続的に監視
  2. このドキュメント（1.project_management_principles.md）との整合性を確認
  3. 矛盾や重複を検出した場合、具体的な修正提案を作成

### 10.3 更新プロセス
1. AIによる変更検出
2. 具体的な修正提案の提示
3. ユーザーの承認
4. ユーザーによるファイル更新
   - ファイル名の命名規則を厳格に遵守
   - 変更履歴の明確な記録

### 10.4 更新の例
- シナリオ：技術スタックの変更
- AIの対応：
  1. 変更点の特定
  2. 影響を受ける可能性のあるセクションの提示
  3. 具体的な修正提案
  4. ユーザーとの協議

### 10.5 プロジェクトリンク
- プロジェクトページ: [https://claude.ai/project/49760db5-e74c-4d67-8a29-d8151c4cc40a](https://claude.ai/project/49760db5-e74c-4d67-8a29-d8151c4cc40a)

## 結論

このプロジェクト管理原則は、個人開発とAI主導の開発の柔軟性を反映しています。形式主義を排除し、学習、実験、迅速な改善に焦点を当てます。Super Morioは、技術的探求と創造性の旅です。